#include <ros/ros.h>
#include <iostream>
#include <pcl/io/pcd_io.h>
#include <sensor_msgs/PointCloud2.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/registration/icp.h>
#include <pcl_ros/filters/passthrough.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <boost/thread.hpp>



ros::Publisher pub;


pcl::PointCloud<pcl::PointXYZ>::Ptr final_cloud (new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr prev_cloud (new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out (new pcl::PointCloud<pcl::PointXYZ>); pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in (new pcl::PointCloud<pcl::PointXYZ>);

bool firstPass = true;
bool update= false;

boost::mutex updateMutex;

void filter_input_points(const sensor_msgs::PointCloud2ConstPtr& input)
{
  boost::mutex::scoped_lock updateLock(updateMutex);
  sensor_msgs::PointCloud2 output;

  pcl::fromROSMsg(*input,*cloud_in);

  std::vector<int> indices;
  pcl::removeNaNFromPointCloud(*cloud_in,*cloud_in,indices);

  pcl::VoxelGrid<pcl::PointXYZ> downsample_cloud;
  downsample_cloud.setInputCloud(cloud_in);
  downsample_cloud.setLeafSize(0.01f,0.01f,0.01f);
  downsample_cloud.filter(*cloud_in);


  if(firstPass){
	std::cout << "final cloud size = " << final_cloud->size()<< std::endl;
	prev_cloud = cloud_in;
	pcl::toROSMsg(*prev_cloud,output);
	pub.publish(output);
	update = true;
	updateLock.unlock();
	firstPass = false;}
	
  else{
	
	  pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;

	  icp.setInputSource(prev_cloud);
          std::cout << "cloud_in size = " << cloud_in ->size() << std::endl;
	  icp.setInputTarget(cloud_in);
	  icp.align(*cloud_out);
	  std::cout << "cloud_out size = " << cloud_out ->size() << std::endl;
	  if(icp.hasConverged()){
		 *final_cloud += *cloud_out;
		  prev_cloud = cloud_in; 
		  std::cout << "final cloud size = " << final_cloud->size()<< std::endl;
		  std::cout << "has converged:" << icp.hasConverged() << " score: " << 		icp.getFitnessScore() <<std::endl;
		  std::cout << icp.getFinalTransformation() << std::endl; 
		  pcl::toROSMsg(*final_cloud,output);
		  pub.publish(output);
		  update= true;
		  updateLock.unlock();

	 }
	 else{
	 	PCL_ERROR("\nICP has not converged. \n");
	 }}

}

boost::shared_ptr<pcl::visualization::PCLVisualizer> viewportsVis(){
	boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("ICP Viewer"));
	int v1(0);
	int v2(1);
	int v3(2);
	
	viewer->createViewPort(0.0,0.5,0.5,1.0,v1);
	viewer->createViewPort(0.5,0.5,1.0,1.0,v2);
	viewer->createViewPort(0.0,0.0,1.0,0.5,v3);
	
	viewer->addText("Current Cloud",10,10,"v1 text",v1);
	viewer->addText("Previous Cloud",10,10,"v2 text",v2);
	viewer->addText("Output Cloud",10,10,"v3 text",v3);
	
	
	
	
	viewer->addCoordinateSystem(1.0);
	
	return viewer;
}

void updateVisualizer(){
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer = viewportsVis();
  
  while(!viewer->wasStopped()){
  	viewer->spinOnce(100);
  
  	boost::mutex::scoped_lock updateLock(updateMutex);
  	if(update){
  	
  	  if(!viewer -> updatePointCloud(cloud_in,"cloud_in")){
  	  	viewer -> addPointCloud(cloud_in,"cloud_in",0);
  	  }
  	  if(!viewer -> updatePointCloud(prev_cloud,"prev_cloud")){
  	  	viewer -> addPointCloud(prev_cloud,"prev_cloud",1);	
  	  }
  	  if(!viewer -> updatePointCloud(cloud_out,"cloud_out")){
  	  	viewer -> addPointCloud(prev_cloud,"cloud_out",2);
  	  }  		
	  update = false;}
	  
	  updateLock.unlock();
	  }
}




int main (int argc, char** argv){
  
  
  

  
  ros::init (argc, argv, "kinect_pcl");
  ros::NodeHandle nh;
  ros::Rate loop_rate (1000);
 
  ros::Subscriber sub = nh.subscribe(
                    "/camera/depth/points",
                    2,
                    filter_input_points
                    );             
  
  boost::thread visualizerThread (updateVisualizer);
                    
  while(ros::ok()){

  pub = nh.advertise<sensor_msgs::PointCloud2> ("output",1);

  ros::spinOnce();
  loop_rate.sleep();
 }
 visualizerThread.join();
 return 0;
}

